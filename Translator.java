/* * Object-Oriented Programming * Copyright (C) 2010 Robert Grimm * edits (C) 2010 P.Hammer, A.Krebs, L. Pelka, P.Ponzeka * * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * version 2 as published by the Free Software Foundation. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, * USA. */package xtc.oop;import java.io.File;import java.io.IOException;import java.io.Reader;import xtc.lang.JavaFiveParser;import xtc.parser.ParseException;import xtc.parser.Result;import java.util.HashMap;import xtc.tree.GNode;import xtc.tree.Node;import xtc.tree.Visitor;import java.util.ArrayList;import xtc.util.Tool;/** * A translator from (a subset of) Java to (a subset of) C++. * * @author P.Hammer * @author A.Krebs * @author L. Pelka * @author P.Ponzeka * @version 1 */public class Translator extends Tool {	File inputFile = null;        HashMap<DependencyFinder,Boolean> allDependencies;        HashMap<ClassStruct,Boolean> classes;	/** Create a new translator. */	public Translator() {			}        public Translator (HashMap<DependencyFinder,Boolean> dependencies,                    HashMap<ClassStruct,Boolean> classes) {            this();            this.allDependencies = dependencies;            this.classes = classes;        }	public String getCopy() {		return "(C) 2010 P.Hammer, A.Krebs, L. Pelka, P.Ponzeka";	}	public String getName() {		return "Java to C++ Translator";	}	public String getExplanation() {		return "This tool translates a subset of Java to a subset of C++.";	}	public void init() {		super.init();				// Declare command line arguments.		runtime.			bool("printJavaAST", "printJavaAST", false,				 "Print the Java AST.").			bool("countMethods", "optionCountMethods", false,				 "Print the number of method declarations.").			bool("translate", "translate", false,				 "Translate .java file to c++.").			bool("finddependencies", "finddependencies", false,				 "find all classes we need to translate").				bool("testing","testing",false,"Run some Test cases.").			bool("tester","tester",false,"Run tester Class").			bool("test","test",false,"Run some Test cases.");	}	public void prepare() {		super.prepare();		// Perform consistency checks on command line arguments.	}	public File locate(String name) throws IOException {		File file = super.locate(name);		if (Integer.MAX_VALUE < file.length()) {			throw new IllegalArgumentException(file + ": file too large");		}		inputFile = file;		//System.out.println("using this method");		return file;	}	public Node parse(Reader in, File file) throws IOException, ParseException {		JavaFiveParser parser =			new JavaFiveParser(in, file.toString(), (int)file.length());		Result result = parser.pCompilationUnit(0);		return (Node)parser.value(result);	}	/**	 * helper method test how many classes left to translate at any moment	 */	public int numFalse() {		int numRemaining = 0;		for (Boolean b : classes.values()) {			if (!b)numRemaining++;		}		return numRemaining;	}	//-----------------------------------------------------------------------	public void process(Node node) {		final boolean VERBOSE = runtime.test("optionVerbose");		final boolean SILENT  = runtime.test("optionSilent");				//Some Testing Environments		if(runtime.test("testing"))			{				runtime.console().p("Testing...").pln().flush();							/*Create a new visitor to visit the CompilationUnit */				new Visitor(){					public void visitBlock(GNode n)					{						CppPrinter print= new CppPrinter(n,true);						//print.DEBUG=true;											}					public void visit(Node n)					{						for(Object o:n) {							if(o instanceof Node) dispatch((Node) o);												}					}				}.dispatch(node);						}		/*		 * runtime option TRANSLATE 		 *		 */		if (runtime.test("translate")) {							if (VERBOSE) {					runtime.console().p("Begining translation...").pln().flush();				}                 			String fullPathName = "";			try { fullPathName = inputFile.getCanonicalPath(); }			catch (IOException e) { }                    			// recursively find dependencies from input file			Translator t = new Translator(allDependencies, classes);			t.run(new String[]{"-no-exit", "-finddependencies", fullPathName});			classes = t.classes;			allDependencies =t.allDependencies;			for(DependencyFinder d: allDependencies.keySet()) System.out.println(d+" "+d.getFilePath());			for(ClassStruct c: classes.keySet()) System.out.println(c+" "+c.className);					  			//creates tree root a.k.a. the Object class			final InheritanceTree Object = new InheritanceTree();					  			//creates the Class class as subclass of Object class			final InheritanceTree Class = new InheritanceTree(Object);								 			//---- creates all InheritanceTrees ----			int leftTotranslate = classes.size();			while(classes.containsValue(false)){				for(ClassStruct c : classes.keySet()){					if( c.superClass.equals("")){//*** extends object						new InheritanceTree(c.getPackage(),c.n,Object);						classes.put(c,true);					}					else{						InheritanceTree superclass = Object.search(c.getPackage(),c.superClass);							if (superclass!=null){//**extends an already translated class							new InheritanceTree(c.getPackage(),c.n,superclass);							classes.put(c,true);						}					}				}								if (leftTotranslate == numFalse())System.out.println("infiniteloop");//**infiniteloop test				leftTotranslate = classes.size();//**update for infiniteloop			}					 			//----- creates all InheritanceBuilders			InheritanceBuilder inherit;			for (DependencyFinder d: allDependencies.keySet()){				inherit=new InheritanceBuilder(d);				for (ClassStruct c: d.getFileClasses()){					inherit.addMethodDec(Object.search(c.getPackage(),c.className));				}				try{inherit.close();}				catch(Exception e){}			}						                   			if (VERBOSE) //prints the ast after every translation			{				runtime.console().format(node).pln().flush();			}		}//end of runtime.test("Translate") test//-----------------------------------------------------------------------		if (runtime.test("finddependencies")) {                /* find dependencies of a single file, recursively calling until dependency list is filled */			String fullPathName = "";			try { fullPathName = inputFile.getCanonicalPath(); }			catch (IOException e) { }			DependencyFinder depend = new DependencyFinder(node, fullPathName);							// should this be here????				//allDependencies.put(depend, true);                                        for (ClassStruct c : depend.getFileClasses())                        classes.put(c, false);                    Translator t = null;                    ArrayList<FileDependency> toTranslate = new ArrayList<FileDependency>();                    // add all explicitly imported files first before adding package to maintain precedence                    for ( FileDependency f : depend.getFileImportDepPaths() ) {                        // only translate if not translated. get returns a boolean                        // telling whether the file has been translated                        if ( !containsKey(allDependencies, f) || !get(allDependencies, f.fullPath) ) {                            toTranslate.add(f);                        }                    }                    // next add files imported from packages                    for ( FileDependency f : depend.getFilePkgDepPaths() ) {                        // only translate if not translated. dependencies.get(filename) returns                        // a boolean specifiying whether the file has been translated                        if ( !containsKey(allDependencies, f) || !get(allDependencies, f.fullPath) ) {                            try {                                FileDependency temp = toTranslate.get(toTranslate.indexOf(f));                                if ((temp.origin.compareTo(DependencyOrigin.IMPORTEDPACKAGE) < 0) ) // don't add if already explictly imported                                    break;                            } catch (IndexOutOfBoundsException e) {                                toTranslate.add(f);                            }                                                        }                    }                    for (FileDependency f : toTranslate) {                        allDependencies.put(depend, true);                        t = new Translator(allDependencies, classes);                        t.run( new String[] {"-no-exit", "-finddependencies", f.fullPath});                        allDependencies.putAll(t.allDependencies);                    }		}		if (runtime.test("printJavaAST")) {			runtime.console().format(node).pln().flush();		}	}//end of process method        /** helper methods for translator */		          public static boolean containsKey (HashMap<DependencyFinder,Boolean> allDependencies,                                    FileDependency file) {            ArrayList<DependencyFinder> deps = new ArrayList<DependencyFinder>(allDependencies.keySet());            for (DependencyFinder f : deps) {                if (f.equals(file.fullPath))                    return true;            }            return false;        }        public static boolean get (HashMap<DependencyFinder,Boolean> allDependencies, String filename) {            for (DependencyFinder f : allDependencies.keySet()) {                if (f.equals(filename))                    return allDependencies.get(f);            }				return false;            //throw new RuntimeException("Not in dependencies list. Bad");        }    /**	 * Run the translator with the specified command line arguments.	 *	 * Uses xtc.util.tool run();	 * @param args The command line arguments.	 */	public static void main(String[] args) {		HashMap<DependencyFinder,Boolean> dependencies = new HashMap<DependencyFinder,Boolean>();		HashMap<ClassStruct,Boolean> classes = new HashMap<ClassStruct,Boolean>(); 		new Translator(dependencies, classes).run(args);			}	}//end of Translator.java